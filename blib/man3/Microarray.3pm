.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Microarray 3"
.TH Microarray 3 "2008-08-05" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Microarray \- A Perl module for creating and manipulating DNA Microarray experiment objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Microarray;
\&
\&        my $oArray = microarray\->new($barcode,$data_file);
\&        
\&        # QC filtering of our data
\&        $oArray\->set_param(min_diameter=>100,min_snr=>10,low_signal=>1000,high_signal=>62500);  
\&        $oArray\->set_reporter_data;
\&        
\&        #E\*^print plots
\&        $oArray\->print_ma_plot('/ma_plot.png',scale=>50);
\&        
\&        # direct access to spot and clone level data
\&        my $oData_File = $oArray\->data_file;                                    # the data_file object
\&        my $oSpot = $oData_File\->get_spots(123);                                # returns a single spot object
\&        my $oReporter = $oArray\->get_reporter('RP11\-354D4');    # returns a single reporter object
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1DNA\s0 Microarrays (<http://en.wikipedia.org/wiki/Dna_microarray>) also known as 'Gene Chips' or '\s-1DNA\s0 chips', are an experimental tool used in genetic research and other related disciplines. They consist of thousands of \s-1DNA\s0 probes immobilised on a solid surface (such as a glass slide) and enable high-resolution, high-throughput analyses of a variety of parameters such as gene expression, genetic variation, or chromosome copy number variants.
.Sh "Typically"
.IX Subsection "Typically"
A single Microarray experiment (typically) generates large quantities of data which (typically) requires some form of post-processing before the data can be interpreted or visualised. The processing of microarray data is (typically) handled by a Bioinformatician (<http://en.wikipedia.org/wiki/Bioinformatics>), and the favourite computer programming language of a Bioinformatician is (typically) Perl. However, until now the poor Bioinformatician has (typically) had to use a statistical programming language like R (<http://www.r\-project.org>) \- not because it is intrinsically better for the job than Perl, but rather because there were no \s-1CPAN\s0 modules that helped the Bioinformatician to perform these tasks lazily, impatiently and with hubris.
.PP
Microarray is a suite of object-oriented Perl Modules for the analysis of microarray experiment data. These include modules for handling common formats of microarray files, modules for the programmatic abstraction of a microarray experiment, and for the output of a variety of images describing microarray experiment data. Hopefully, this suite of modules will help Bioinformaticians to (typically) handle their data with laziness, impatience and hubris.
.Sh "How it works"
.IX Subsection "How it works"
The Microarray object contains several levels of microarray associated data, organised in a (fairly) intuitive way. First, there's the data that you have obtained from a microarray scanner, in the form of a data file. This is imported into Microrray as a Data_File object. Support for different data file formats is built into the Data_File class, and creating new classes for your favourite scanner/software output is relatively simple. Data extracted from the microarray spots are then imported into individual array_spot objects. Next, replicate spots are collated into array_reporter objects. Most of the quality control functions operating on parameters such as signal intensity and spot size, are built into this final process, so that an array_reporter object only returns data from spots that have passed the \s-1QC\s0 assessments. Post-processing of the data is then performed using the Microarray::Analysis module, and finally the data are visualised using the Microarray::Image module.
.SH "METHODS"
.IX Header "METHODS"
.Sh "Creating microarray objects"
.IX Subsection "Creating microarray objects"
The microarray object is created by providing a barcode (or name) and a data file. It is assumed the data file contains minimal information about the reporter identities (i.e. name or id). In the case of a CGH-microarray, that means the \s-1BAC\s0 clone name/synonym at each spot. For cDNA or oligo arrays, that would mean a gene name, cDNA accession, or oligo name. Most of the functions between initialising the objects and returning formatted data can be accessed, and default settings can be changed (see below).
.Sh "Data File"
.IX Subsection "Data File"
The data file can be passed to Microarray either as a file name, filehandle object, or data_file object. If a filehandle is passed, the filename also needs to be set.
.PP
.Vb 1
\&        $oArray = microarray\->new($barcode,'my_file');          # will try to guess the file format
\&        
\&        or
\&        
\&        $oData_File = quantarray_file\->new('my_file');          # create the data file...
\&        $oData_File = quantarray_file\->new('my_file',$Fh);  # can pass a filename and filehandle to the data file
\&        $oArray = microarray\->new($barcode,$oData_File);        # ...then load into microarray
.Ve
.Sh "Data file methods"
.IX Subsection "Data file methods"
.IP "\fBfile_name\fR" 4
.IX Item "file_name"
Depending how you used Data_File, will be the name or the full path you provided
.IP "\fBget_header_info\fR" 4
.IX Item "get_header_info"
For example in the ScanArray format, the data header contains information about the scan, such as laser power, \s-1PMT\s0, etc
.Sh "Reporter Identification"
.IX Subsection "Reporter Identification"
.IP "\fBblank_feature\fR" 4
.IX Item "blank_feature"
Defines how 'empty' spots are described in the data file. Default 'n/a'
.IP "\fBprefix\fR" 4
.IX Item "prefix"
Set to 'y' if the reporter id is prefixed in some way (for instance, we use prefixes to distinguish different methods used to prepare the same sample for microarray spotting). Default 'n'
.Sh "Changing Default Settings"
.IX Subsection "Changing Default Settings"
There are many parameters that are used for spot quality control. Below is an overview of the methods used. As well as being able to set these parameters individually, you can also set a number in one call using the \fIset_param()\fR method
.PP
.Vb 1
\&        $oArray\->set_param(min_diameter=>100,min_snr=>10);
.Ve
.PP
\fISpot Quality Control\fR
.IX Subsection "Spot Quality Control"
.PP
There are various (mostly self-explanatory) methods for setting spot quality control measurements, listed below
.IP "\fBlow_signal\fR, \fBhigh_signal\fR" 4
.IX Item "low_signal, high_signal"
Defaults = 5000, 60000
.IP "\fBmin_diameter\fR, \fBmax_diameter\fR" 4
.IX Item "min_diameter, max_diameter"
Default = 80, 150
.IP "\fBmin_pixels\fR" 4
.IX Item "min_pixels"
Default = 80
.IP "\fBsignal_quality\fR" 4
.IX Item "signal_quality"
Varies depending on the data file format used; for the ScanArray format, this refers to the percentage of spot pixels that are more than 2 standard deviations above the background (default = 95); for BlueFuse this corresponds to the spot confidence value.
.IP "\fBpercen_sat\fR" 4
.IX Item "percen_sat"
The method \fIpercen_sat()\fR refers to the percentage of spot pixels that have a saturated signal. Default = 10. Not relevant to BlueFuse format.
.PP
\fISignal Analysis\fR
.IX Subsection "Signal Analysis"
.IP "\fBnormalisation\fR" 4
.IX Item "normalisation"
Set to either 'y' or 'n', to include ratio normalisation. Note: this is only base-level normalisation, not signal normalisation. For CGH-microarrays, this is a subtraction of the modal log2 ratio. Default = 'y'
.Sh "Access to Spot Data"
.IX Subsection "Access to Spot Data"
All of the microarray data can be independently accessed in one of two ways. First, data can be obtained directly from the data file object, and in fact you could use this module just to simplify the data input process for your own applications and not use any of the other functions of Microarray. Individual spot objects can be returned by referring to their spot index (which is usually also the order they appear in the data file) or all spot objects can be returned as a list. See Microarray::Spot and Microarray::Reporter for more information.
.PP
.Vb 4
\&        my $oSpot = $oData_File\->get_spots(1);
\&        my $aAll_Spots = $oData_File\->get_spots;
\&        my $number_of_spots = $aAll_Spots[0];           # first element is not a spot, but the number of spots
\&        my $oSpot1 = $aAll_Spots[1];                            # array index = spot index
.Ve
.Sh "Access to Reporter Data"
.IX Subsection "Access to Reporter Data"
Alternatively you can access the reporter data, which collates replicate spot data. Either, individual reporter objects can be returned, and array_reporter methods applied to them, or all reporter objects/ids can be returned as a list.
.PP
.Vb 4
\&        $oReporter = $oArray\->get_reporter('reporter1');        # returns a single reporter object
\&        $aReporter_Objects = $oArray\->get_reporter_objects; # returns a list of reporter objects
\&        $aReporter_Names = $oArray\->get_reporter_ids;           # returns a list of reporter ids
\&        $hReporters = $oArray\->get_all_reporters;                       # returns a hash of reporters; key=reporter_id, value=reporter object
.Ve
.IP "set_reporter_data" 4
.IX Item "set_reporter_data"
Each Microarray::Spot object is attributed to a Reporter object, and the \s-1QC\s0 process is performed on the filled Reporter objects.
.IP "should_reject_unique" 4
.IX Item "should_reject_unique"
If you call this method before \fIset_reporter_data()\fR, any reporters for which only a single spot passed \s-1QC\s0 will be rejected.
.Sh "Image Output"
.IX Subsection "Image Output"
Microarray will output \s-1QC/QA\s0 plots of the data as \s-1PNG\s0 files, using the Microarray::Image::QC_Plots module. Simply call any of the following methods to create the relevant plot, passing any plot parameters if required.
.PP
.Vb 1
\&        $oArray\->print_ma_plot($file_path,scale=>50);
.Ve
.PP
Mac Os X users beware \- for some unknown reason, Apple's Preview application does not render the scatter or \s-1MA\s0 plots properly.
.IP "\fBplot_ma\fR" 4
.IX Item "plot_ma"
Plots an \s-1MA\s0 plot.
.IP "\fBplot_intensity_scatter\fR" 4
.IX Item "plot_intensity_scatter"
A simple intensity scatter of channel1 signal vs channel2 signal.
.IP "\fBplot_log2_heatmap\fR" 4
.IX Item "plot_log2_heatmap"
A spatial plot of the log2 values from each spot of the array.
.IP "\fBplot_intensity_heatmap\fR" 4
.IX Item "plot_intensity_heatmap"
A spatial plot of the signal intensity of each spot of the array.
.SH "TESTING"
.IX Header "TESTING"
This distribution is not yet fully tested; there are 8 test scripts that cover 14 of the 18 modules included in this distribution, although only 10 of those modules are covered in detail. However, the data files required for execution of the majority of the tests are not included in this distribution because of their size, but instead they are available for download from our Laboratory's web site at the following address;
.PP
<http://www.instituteforwomenshealth.ucl.ac.uk/AcademicResearch/Cancer/trl/pipeline/microarray_test_files.zip>
.SH "FUTURE DEVELOPMENT"
.IX Header "FUTURE DEVELOPMENT"
This module is under continued development for our laboratory's microarray facility. If you would like to contribute to the development of Microarray, whether to add more advanced features of data analysis, or simply to add support for other microarray platforms/scanners, please contact the author.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Microarray::File, Microarray::Reporter, Microarray::Spot, Microarray::Analysis, Microarray::Image
.SH "AUTHOR"
.IX Header "AUTHOR"
Christopher Jones, Gynaecological Cancer Research Laboratories, \s-1UCL\s0 \s-1EGA\s0 Institute for Women's Health, University College London.
.PP
<http://www.instituteforwomenshealth.ucl.ac.uk/AcademicResearch/Cancer/trl/index.html>
.PP
c.jones@ucl.ac.uk
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008 by Christopher Jones, University College London
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
